#!/bin/sh

# ==============================================================================
# Script Name: ADB Proxy & Certificate Manager
# Author:      Darkprince
# Date:        2025-11-18
# Purpose:     Manage HTTP Proxies and Inject System Certificates (Android 10-14+)
# Dependencies: adb, openssl, curl
# Compatibility: Bash, Zsh, POSIX sh
# ==============================================================================

PROXY_HOST="10.0.2.2"
PROXY_PORT="8080"
CERT_URL="http://127.0.0.1:8080/cert"
DEVICE_SERIAL=""

setup_colors() {
    if command -v tput >/dev/null 2>&1 && [ -n "$TERM" ]; then
        RED=$(tput setaf 1)
        GREEN=$(tput setaf 2)
        YELLOW=$(tput setaf 3)
        BLUE=$(tput setaf 4)
        CYAN=$(tput setaf 6)
        NC=$(tput sgr0)
    else
        RED=$(printf '\033[0;31m')
        GREEN=$(printf '\033[0;32m')
        YELLOW=$(printf '\033[1;33m')
        BLUE=$(printf '\033[0;34m')
        CYAN=$(printf '\033[0;36m')
        NC=$(printf '\033[0m')
    fi
}

check_dependencies() {
    for cmd in adb openssl curl; do
        if ! command -v "$cmd" >/dev/null 2>&1; then
            printf "%s[ERROR] Missing dependency: %s%s\n" "$RED" "$cmd" "$NC"
            echo "Please install it via brew, apt, or your package manager."
            exit 1
        fi
    done
}

cleanup_local() {
    rm -f "cert_raw" "cert.pem" "device_installer.sh"
}
trap cleanup_local EXIT INT TERM

print_info() { printf "%s[INFO]%s %s\n" "$BLUE" "$NC" "$1"; }
print_success() { printf "%s[SUCCESS]%s %s\n" "$GREEN" "$NC" "$1"; }
print_warn() { printf "%s[WARN]%s %s\n" "$YELLOW" "$NC" "$1"; }
print_error() { printf "%s[ERROR]%s %s\n" "$RED" "$NC" "$1"; }

ensure_online() {
    if ! adb start-server >/dev/null 2>&1; then
        print_error "Cannot start ADB server."
        return 1
    fi
    
    local state
    state=$(adb -s "$DEVICE_SERIAL" get-state 2>/dev/null)
    if [ "$state" != "device" ]; then
        print_info "Device offline. Waiting for connection..."
        adb -s "$DEVICE_SERIAL" wait-for-device
        print_success "Device reconnected."
    fi
    
    local retries=0
    while ! adb -s "$DEVICE_SERIAL" shell "service check settings" >/dev/null 2>&1; do
        retries=$((retries+1))
        if [ "$retries" -gt 8 ]; then return 0; fi
        sleep 2
    done
    return 0
}

select_device() {
    raw_devices=$(adb devices | grep -v "List of devices attached" | grep -v "^$" | awk '{print $1}')
    
    if [ -z "$raw_devices" ]; then
        print_error "No devices/emulators found."
        exit 1
    fi

    device_count=$(echo "$raw_devices" | wc -l | tr -d ' ')

    if [ "$device_count" -eq 1 ]; then
        DEVICE_SERIAL="$raw_devices"
    else
        print_warn "Multiple devices found. Please select one:"
        i=1
        echo "$raw_devices" | while read -r line; do
            echo "$i) $line"
            i=$((i+1))
        done
        
        printf "%sEnter Number: %s" "$YELLOW" "$NC"
        read -r choice
        
        DEVICE_SERIAL=$(echo "$raw_devices" | sed -n "${choice}p")
        
        if [ -z "$DEVICE_SERIAL" ]; then
            print_error "Invalid selection."
            exit 1
        fi
    fi
    print_info "Selected device: ${CYAN}$DEVICE_SERIAL${NC}"
}

check_proxy_connection() {
    local CHECK_HOST="$PROXY_HOST"
    if [ "$PROXY_HOST" = "10.0.2.2" ]; then CHECK_HOST="127.0.0.1"; fi
    
    print_info "Checking if Proxy Tool is running..."
    if nc -z -w 2 "$CHECK_HOST" "$PROXY_PORT" 2>/dev/null; then
        print_success "Proxy server is UP."
        return 0
    else
        print_error "Could NOT connect to $CHECK_HOST:$PROXY_PORT."
        printf "%sSet proxy anyway? (y/n): %s" "$YELLOW" "$NC"
        read -r REPLY
        case "$REPLY" in
            [yY]*) return 0 ;;
            *) return 1 ;;
        esac
    fi
}

configure_proxy() {
    printf "%sCurrent Configuration: %s%s:%s%s\n" "$YELLOW" "$CYAN" "$PROXY_HOST" "$PROXY_PORT" "$NC"
    
    printf "Enter Host [default: %s]: " "$PROXY_HOST"
    read -r NEW_HOST
    if [ -n "$NEW_HOST" ]; then PROXY_HOST="$NEW_HOST"; fi
    
    printf "Enter Port [default: %s]: " "$PROXY_PORT"
    read -r NEW_PORT
    if [ -n "$NEW_PORT" ]; then PROXY_PORT="$NEW_PORT"; fi
    
    print_info "Configuration updated."
    start_proxy
}

start_proxy() {
    if check_proxy_connection; then
        ensure_online || return
        adb -s "$DEVICE_SERIAL" shell settings put global http_proxy "$PROXY_HOST:$PROXY_PORT" 2>/dev/null
        print_success "Proxy set to ${CYAN}$PROXY_HOST:$PROXY_PORT${NC}"
        get_proxy
    else
        print_info "Cancelled."
    fi
}

stop_proxy() {
    ensure_online || return
    adb -s "$DEVICE_SERIAL" shell settings put global http_proxy :0 2>/dev/null
    adb -s "$DEVICE_SERIAL" shell settings delete global global_http_proxy_host 2>/dev/null
    adb -s "$DEVICE_SERIAL" shell settings delete global global_http_proxy_port 2>/dev/null
    print_success "Proxy stopped."
    get_proxy
}

get_proxy() {
    ensure_online || return
    current_proxy=$(adb -s "$DEVICE_SERIAL" shell settings get global http_proxy 2>/dev/null | tr -d '\r')
    
    if [ "$current_proxy" = "null" ] || [ "$current_proxy" = ":0" ] || [ -z "$current_proxy" ]; then
        printf "Current Status: %sNo Proxy%s\n" "$GREEN" "$NC"
    else
        printf "Current Status: %sProxy Active (%s)%s\n" "$RED" "$current_proxy" "$NC"
    fi
}

prepare_cert() {
    print_info "Downloading certificate..."
    local RAW_CERT="cert_raw"
    local PEM_CERT="cert.pem"
    curl -s -o "$RAW_CERT" "$CERT_URL"
    
    if [ ! -s "$RAW_CERT" ]; then
        print_error "Failed to download certificate."
        return 1
    fi
    
    if file "$RAW_CERT" | grep -q "text"; then
        cp "$RAW_CERT" "$PEM_CERT"
    else
        openssl x509 -inform DER -in "$RAW_CERT" -out "$PEM_CERT" 2>/dev/null
        if [ ! -s "$PEM_CERT" ]; then print_error "Conversion failed."; return 1; fi
    fi
    
    CERT_HASH=$(openssl x509 -inform PEM -subject_hash_old -in "$PEM_CERT" | head -1)
    if [ -z "$CERT_HASH" ]; then print_error "Failed to calculate hash."; return 1; fi
    print_info "Hash: ${CYAN}$CERT_HASH${NC}"
    return 0
}

install_system_certificate() {
    ensure_online || return
    prepare_cert || return

    local DEVICE_TMP_PATH="/data/local/tmp"
    local CERT_FILENAME="$CERT_HASH.0"
    
    print_info "Pushing certificate..."
    adb -s "$DEVICE_SERIAL" push "cert.pem" "$DEVICE_TMP_PATH/$CERT_FILENAME" > /dev/null
    
    # Generate Installer Script (Run on device)
    cat <<EOF > device_installer.sh
#!/system/bin/sh
CERT_FILE="$DEVICE_TMP_PATH/$CERT_FILENAME"
RAM_DISK="/data/local/tmp/cert_overlay_$CERT_HASH"
LEGACY_PATH="/system/etc/security/cacerts"

SDK=\$(getprop ro.build.version.sdk)
if [ "\$SDK" -ge 34 ]; then
    RAW_PATH="/apex/com.android.conscrypt/cacerts"
    if [ -f /system/bin/realpath ]; then
        TARGET_PATH=\$(realpath "\$RAW_PATH" 2>/dev/null || echo "\$RAW_PATH")
    else
        TARGET_PATH="\$RAW_PATH"
    fi
    DO_DUAL_MOUNT=1
else
    TARGET_PATH="\$LEGACY_PATH"
    DO_DUAL_MOUNT=0
fi

echo "Target Path: \$TARGET_PATH"

setenforce 0

mkdir -p "\$RAM_DISK"
mount -t tmpfs tmpfs "\$RAM_DISK"

cp "\$TARGET_PATH"/* "\$RAM_DISK/"
cp "\$CERT_FILE" "\$RAM_DISK/"

chown 0:0 "\$RAM_DISK"/*
chmod 644 "\$RAM_DISK"/*
chcon u:object_r:system_file:s0 "\$RAM_DISK"/*

mount --bind "\$RAM_DISK" "\$TARGET_PATH"

if [ "\$DO_DUAL_MOUNT" -eq 1 ]; then
    mount --bind "\$RAM_DISK" "\$LEGACY_PATH"
fi

if ls "\$TARGET_PATH/$CERT_FILENAME" >/dev/null 2>&1; then
    echo "SUCCESS_TEMPORARY"
else
    echo "FAILURE"
    exit 1
fi

inject_mount() {
    local PID=\$1
    [ -z "\$PID" ] && return
    if [ ! -f "/proc/\$PID/ns/mnt" ]; then return; fi

    if [ -d "\$TARGET_PATH" ]; then
        nsenter --mount=/proc/\$PID/ns/mnt -- /system/bin/mount --bind "\$RAM_DISK" "\$TARGET_PATH"
    fi
    
    if [ "\$DO_DUAL_MOUNT" -eq 1 ]; then
        nsenter --mount=/proc/\$PID/ns/mnt -- /system/bin/mount --bind "\$RAM_DISK" "\$LEGACY_PATH"
    fi
}

ZYGOTE_PID=\$(pidof zygote || true)
ZYGOTE64_PID=\$(pidof zygote64 || true)

for PID in \$ZYGOTE_PID \$ZYGOTE64_PID; do
    inject_mount \$PID
done

for PID in \$(ls /proc); do
    case "\$PID" in
        ''|*[!0-9]*) continue ;;
    esac
    
    if [ -f "/proc/\$PID/stat" ]; then
        PPID=\$(cat "/proc/\$PID/stat" | awk '{print \$4}')
        if [ "\$PPID" = "\$ZYGOTE_PID" ] || [ "\$PPID" = "\$ZYGOTE64_PID" ]; then
             inject_mount \$PID &
        fi
    fi
done
wait

echo "SUCCESS_INJECTED"
EOF

    adb -s "$DEVICE_SERIAL" push device_installer.sh "$DEVICE_TMP_PATH/installer.sh" > /dev/null
    
    print_info "Executing Live Injection..."
    local CMD="nsenter --mount=/proc/1/ns/mnt /system/bin/sh $DEVICE_TMP_PATH/installer.sh 2>/dev/null || su -mm -c 'sh $DEVICE_TMP_PATH/installer.sh' 2>/dev/null || su -c 'sh $DEVICE_TMP_PATH/installer.sh'"
    
    local OUTPUT
    OUTPUT=$(adb -s "$DEVICE_SERIAL" shell "su -c \"$CMD\"")
    
    # Verbose output for user clarity
    case "$OUTPUT" in
        *"SUCCESS_INJECTED"*)
            print_success "Certificate injected via RAM Overlay!"
            echo ""
            print_warn "!!! IMPORTANT: THIS INJECTION IS TEMPORARY !!!"
            print_info "The certificate effectively exists in the device RAM."
            print_info "It will be WIPED AUTOMATICALLY when the device REBOOTS."
            print_info "If you restart this device, you MUST run Option 5 again."
            echo ""
            print_success "Injection applied to:"
            print_info "  - System Path (Apps)"
            print_info "  - Legacy Path (Chrome Compatibility)"
            print_info "  - Zygote (New Apps)"
            print_info "  - Running Apps (Immediate)"
            
            cleanup_local
            adb -s "$DEVICE_SERIAL" shell "rm $DEVICE_TMP_PATH/$CERT_FILENAME $DEVICE_TMP_PATH/installer.sh"
            ;;
        *)
            print_error "Injection failed. Device output:"
            echo "$OUTPUT"
            ;;
    esac
}

install_user_certificate() {
    ensure_online || return
    prepare_cert || return
    
    print_info "Pushing certificate to Downloads..."
    adb -s "$DEVICE_SERIAL" push "cert.pem" "/sdcard/Download/burp_cert.crt" > /dev/null
    
    print_warn "--- MANUAL INTERACTION REQUIRED ---"
    print_info "I have pushed 'burp_cert.crt' to /sdcard/Download/"
    print_info "Please perform the following steps on your device:"
    print_info "1. In Settings. Look For CA Certificate"
    print_info "2. Tap 'Install a certificate' -> 'CA certificate'."
    print_info "3. Tap 'Install Anyway' if prompted."
    print_info "4. Select 'burp_cert.crt' from Downloads."
    
    echo ""
    print_info "Opening Encryption & Credentials Settings..."
    
    # Try primary method (Android 11+)
    adb -s "$DEVICE_SERIAL" shell "am start -a android.settings.ENCRYPTION_AND_CREDENTIALS_SETTINGS" >/dev/null 2>&1
    
    # Fallback for older devices or different skins
    adb -s "$DEVICE_SERIAL" shell "am start -a android.settings.SECURITY_SETTINGS" >/dev/null 2>&1
    
    # Fallback to generic settings if all else fails
    adb -s "$DEVICE_SERIAL" shell "am start -a android.settings.SETTINGS" >/dev/null 2>&1
    
    print_success "Check your device screen now."
}

show_menu() {
    echo ""
    printf "%s--- Actions ---%s\n" "$CYAN" "$NC"
    echo "1) Start Proxy"
    echo "2) Change Proxy Config"
    echo "3) Stop Proxy"
    echo "4) Get Proxy Status"
    echo "5) Install System Certificate (Live Injection)"
    echo "6) Install User Certificate (Chrome Fix Android 14+)"
    echo "m) Show menu"
    echo "q) Quit"
}

# --- Main Execution ---
setup_colors
check_dependencies
printf "%s=== ADB Proxy & Cert Manager ===%s\n" "$CYAN" "$NC"
select_device
show_menu

while true; do
    printf "\n%s?# %s" "$YELLOW" "$NC"
    read -r choice
    case "$choice" in
        1) start_proxy ;;
        2) configure_proxy ;;
        3) stop_proxy ;;
        4|get) get_proxy ;;
        5) install_system_certificate ;;
        6) install_user_certificate ;;
        m|menu) show_menu ;;
        q|quit) print_info "Exiting..."; exit 0 ;;
        *) print_error "Invalid option." ;;
    esac
done